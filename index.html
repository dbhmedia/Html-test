<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Camera App: Simplified UFO Filter (Non-Recursive)</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: black;
      width: 100%;
      height: 100%;
      touch-action: none;
    }
    #videoContainer {
      position: relative;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: row;
      justify-content: center;
      align-items: center;
    }
    video, canvas {
      position: absolute;
      width: 50%;
      height: 100%;
      object-fit: cover;
    }
    #video1, #canvas1 {
      left: 0;
    }
    #video2, #canvas2 {
      right: 0;
    }
    /* Menu styles */
    #menu {
      position: absolute;
      top: 10%;
      left: 50%;
      transform: translateX(-50%);
      background-color: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border-radius: 10px;
      display: none;
      color: white;
      z-index: 2;
    }
    #menu h2 {
      margin-top: 0;
    }
    .sliderContainer {
      margin: 10px 0;
    }
    .sliderLabel {
      margin-bottom: 5px;
    }
    .slider {
      width: 100%;
    }
    .valueDisplay {
      color: #fff;
      font-size: 14px;
      margin-left: 10px;
    }
    /* Button styles */
    .button {
      background-color: #444;
      color: white;
      padding: 10px;
      margin: 10px 0;
      border: none;
      border-radius: 5px;
      width: 100%;
      font-size: 16px;
    }
    /* Full-screen toggle overlay */
    #fullscreenOverlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }
    /* Camera label overlay */
    #cameraLabel {
      position: absolute;
      top: 10px;
      right: 10px;
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 5px 10px;
      border-radius: 5px;
      z-index: 3;
      font-size: 16px;
      display: none;
    }
  </style>
</head>
<body>
  <div id="videoContainer">
    <video id="video1" autoplay playsinline></video>
    <video id="video2" autoplay playsinline></video>
    <canvas id="canvas1"></canvas>
    <canvas id="canvas2"></canvas>
  </div>

  <!-- Full-screen toggle overlay -->
  <div id="fullscreenOverlay"></div>

  <!-- Camera label overlay -->
  <div id="cameraLabel">Cam 1</div>

  <!-- Menu for adjustments -->
  <div id="menu">
    <h2>Adjustments</h2>
    <!-- Flip Camera Button -->
    <button id="flipCameraBtn" class="button">Flip Camera</button>
    <!-- HDR Toggle -->
    <button id="hdrToggleBtn" class="button">Enable HDR</button>
    <!-- Frame Rate Adjustment -->
    <div class="sliderContainer">
      <div class="sliderLabel">Frame Rate</div>
      <input type="range" id="frameRate" class="slider" min="15" max="60" value="30">
      <span id="frameRateValue" class="valueDisplay">30 fps</span>
    </div>
    <!-- Resolution Adjustment -->
    <div class="sliderContainer">
      <div class="sliderLabel">Resolution</div>
      <select id="resolution" class="slider">
        <option value="1280x720">720p</option>
        <option value="1920x1080">1080p</option>
      </select>
    </div>
    <!-- Brightness Adjustment -->
    <div class="sliderContainer">
      <div class="sliderLabel">Brightness</div>
      <input type="range" id="brightness" class="slider" min="0" max="20" value="10">
      <span id="brightnessValue" class="valueDisplay">10</span>
    </div>
    <!-- Contrast Adjustment -->
    <div class="sliderContainer">
      <div class="sliderLabel">Contrast</div>
      <input type="range" id="contrast" class="slider" min="0" max="20" value="20">
      <span id="contrastValue" class="valueDisplay">20</span>
    </div>
  </div>

  <script>
    (function() {
      const video1 = document.getElementById('video1');
      const video2 = document.getElementById('video2');
      const canvas1 = document.getElementById('canvas1');
      const canvas2 = document.getElementById('canvas2');
      const ctx1 = canvas1.getContext('2d');
      const ctx2 = canvas2.getContext('2d');
      const menu = document.getElementById('menu');
      const flipCameraBtn = document.getElementById('flipCameraBtn');
      const hdrToggleBtn = document.getElementById('hdrToggleBtn');

      // Sliders
      const frameRateSlider = document.getElementById('frameRate');
      const frameRateValue = document.getElementById('frameRateValue');
      const resolutionSelect = document.getElementById('resolution');

      const brightnessSlider = document.getElementById('brightness');
      const brightnessValue = document.getElementById('brightnessValue');
      const contrastSlider = document.getElementById('contrast');
      const contrastValue = document.getElementById('contrastValue');

      const leftX = document.getElementById('leftX');
      const leftY = document.getElementById('leftY');
      const rightX = document.getElementById('rightX');
      const rightY = document.getElementById('rightY');

      // Camera label overlay
      const cameraLabelOverlay = document.getElementById('cameraLabel');

      // Touch variables
      let initialPinchDistance = null;
      let lastZoom = 1;
      let isMenuVisible = false;

      // Cameras
      let stream = null;
      let track = null;
      let capabilities = null;
      let settings = null;
      let currentZoom = 1;
      let isFrontCamera = false;
      let hdrEnabled = false;

      let videoDevices = [];
      let currentCameraToggleIndex = 0;
      let cameraLabels = [];

      // Voice recognition
      let recognition = null;
      let isListening = false;

      // filterMode: 0 = no filter, 1 = motion, 2 = UFO
      let filterMode = 0;

      /*************************************************
       * MOTION FILTER VARIABLES
       *************************************************/
      let amplificationFactor = 100; // 0..100
      let sensitivity = 1.0;        // 0..1
      let smoothingFactor = 0.5;    // for motion

      /*************************************************
       * UFO FILTER VARIABLES
       *************************************************/
      // We'll track the single brightest pixel in the raw feed.
      // Then we'll digitally zoom in around that pixel.
      // We'll do a simple "smoothing" so the center doesn't jerk around.
      let ufoCenterX = 0.5;
      let ufoCenterY = 0.5;
      let ufoDigitalZoom = 3.0;   // default to 3x
      let ufoSmoothing = 0.9;     // 0.0 = no smoothing, 1.0 = never move

      //--- Setup & Start ------------------------------------------------------
      async function init() {
        await getVideoDevices();
        if (videoDevices.length === 0) {
          alert('No video devices found.');
          return;
        }

        currentCameraToggleIndex = 0;
        await restartCamera();

        document.addEventListener('touchstart', handleTouchStart, false);
        document.addEventListener('touchmove', handleTouchMove, false);
        document.addEventListener('touchend', handleTouchEnd, false);

        updateFrameRate();
        applyBrightnessContrast();

        startVoiceRecognition();

        processFrames();

        // Position sliders
        updateVideoPositions();
      }

      init();

      //--- Enumerate Cameras -------------------------------------------------
      async function getVideoDevices() {
        const devices = await navigator.mediaDevices.enumerateDevices();
        videoDevices = devices.filter(d => d.kind === 'videoinput');
        cameraLabels = videoDevices.map((device, i) => `Cam ${i + 1}`);
      }

      //--- Start / Restart Camera --------------------------------------------
      async function restartCamera() {
        const deviceId = videoDevices[currentCameraToggleIndex]?.deviceId;
        await startCamera(deviceId, isFrontCamera ? 'user' : 'environment');
      }

      async function startCamera(deviceId, facingMode) {
        if (stream) {
          stream.getTracks().forEach(t => t.stop());
        }

        // Gather constraints
        const frameRate = parseInt(frameRateSlider.value);
        const [width, height] = resolutionSelect.value.split('x').map(Number);

        let constraints = {
          audio: false,
          video: {
            width: { ideal: width },
            height: { ideal: height },
            frameRate: { ideal: frameRate },
          },
        };

        if (deviceId) {
          constraints.video.deviceId = { exact: deviceId };
        } else if (facingMode) {
          constraints.video.facingMode = { exact: facingMode };
        } else {
          constraints.video.facingMode = { ideal: 'environment' };
        }

        try {
          stream = await navigator.mediaDevices.getUserMedia(constraints);
          video1.srcObject = stream;
          video2.srcObject = stream;

          track = stream.getVideoTracks()[0];
          capabilities = track.getCapabilities ? track.getCapabilities() : {};
          settings = track.getSettings ? track.getSettings() : {};

          updateCameraLabel();

          if (capabilities.zoom) {
            currentZoom = capabilities.zoom.min || 1;
            lastZoom = currentZoom;
          }

          video1.onloadedmetadata = () => {
            canvas1.width = video1.videoWidth;
            canvas1.height = video1.videoHeight;
          };
          video2.onloadedmetadata = () => {
            canvas2.width = video2.videoWidth;
            canvas2.height = video2.videoHeight;
          };
        } catch (err) {
          console.error('Camera start error:', err);
          alert(`Error starting camera: ${err.message}`);
        }
      }

      //--- Filters -----------------------------------------------------------
      function processFrames() {
        if (filterMode === 1) {
          // Motion filter
          processMotionFrame(video1, canvas1, ctx1);
          processMotionFrame(video2, canvas2, ctx2);
        } else if (filterMode === 2) {
          // UFO filter
          processUfoFrame(video1, canvas1, ctx1);
          processUfoFrame(video2, canvas2, ctx2);
        }
        // If filterMode=0, just let videos display normally
        requestAnimationFrame(processFrames);
      }

      //---------------- MOTION FILTER ----------------
      function processMotionFrame(videoElement, canvasElement, ctx) {
        if (!videoElement || videoElement.readyState < 2) return;

        // Offscreen is same size as the actual video feed
        const offscreen = document.createElement('canvas');
        offscreen.width = videoElement.videoWidth;
        offscreen.height = videoElement.videoHeight;
        const offCtx = offscreen.getContext('2d');

        // Draw raw camera feed to offscreen
        offCtx.drawImage(videoElement, 0, 0);

        // Grab its pixel data
        const currentFrame = offCtx.getImageData(0, 0, offscreen.width, offscreen.height);
        let previousFrameData = videoElement.previousFrameData;

        if (previousFrameData) {
          const data = currentFrame.data;
          const prevData = previousFrameData.data;
          const len = data.length;
          const threshold = 255 * (1 - sensitivity);

          // Output buffer
          const outputData = new Uint8ClampedArray(len);

          for (let i = 0; i < len; i += 4) {
            const diffR = data[i] - prevData[i];
            const diffG = data[i + 1] - prevData[i + 1];
            const diffB = data[i + 2] - prevData[i + 2];

            const motionVal = Math.sqrt(diffR * diffR + diffG * diffG + diffB * diffB);

            // Smoothing into prev
            prevData[i]   = prevData[i]   * smoothingFactor + data[i]   * (1 - smoothingFactor);
            prevData[i+1] = prevData[i+1] * smoothingFactor + data[i+1] * (1 - smoothingFactor);
            prevData[i+2] = prevData[i+2] * smoothingFactor + data[i+2] * (1 - smoothingFactor);

            if (motionVal > threshold) {
              // Amplify differences
              outputData[i]   = clamp(data[i]   + diffR * amplificationFactor);
              outputData[i+1] = clamp(data[i+1] + diffG * amplificationFactor);
              outputData[i+2] = clamp(data[i+2] + diffB * amplificationFactor);
            } else {
              // Keep original
              outputData[i]   = data[i];
              outputData[i+1] = data[i+1];
              outputData[i+2] = data[i+2];
            }
            outputData[i+3] = 255;
          }

          // Put final
          const outFrame = new ImageData(outputData, offscreen.width, offscreen.height);
          offCtx.putImageData(outFrame, 0, 0);
        }
        // Save currentFrame as previous
        videoElement.previousFrameData = currentFrame;

        // Now draw offscreen to actual canvas
        ctx.drawImage(offscreen, 0, 0, canvasElement.width, canvasElement.height);
      }

      function clamp(v) {
        return Math.max(0, Math.min(255, v));
      }

      //---------------- UFO FILTER ----------------
      function processUfoFrame(videoElement, canvasElement, ctx) {
        if (!videoElement || videoElement.readyState < 2) return;

        // 1) Make an offscreen canvas the size of the actual video feed
        const offscreen = document.createElement('canvas');
        offscreen.width = videoElement.videoWidth;
        offscreen.height = videoElement.videoHeight;
        const offCtx = offscreen.getContext('2d');

        // 2) Draw the raw camera feed onto the offscreen (unaltered)
        offCtx.drawImage(videoElement, 0, 0);

        // 3) Read its pixels
        const frameData = offCtx.getImageData(0, 0, offscreen.width, offscreen.height);

        let brightestVal = -1;
        let brightestX = 0;
        let brightestY = 0;

        // 4) Find the single brightest pixel
        const len = frameData.data.length;
        for (let i = 0; i < len; i += 4) {
          const r = frameData.data[i];
          const g = frameData.data[i + 1];
          const b = frameData.data[i + 2];
          const bright = (r + g + b) / 3;
          if (bright > brightestVal) {
            brightestVal = bright;
            // index to x,y:
            let pixelIndex = i / 4;
            brightestX = pixelIndex % offscreen.width;
            brightestY = Math.floor(pixelIndex / offscreen.width);
          }
        }

        // If nothing bright, just show the raw feed
        if (brightestVal < 0) {
          ctx.drawImage(offscreen, 0, 0, canvasElement.width, canvasElement.height);
          return;
        }

        // 5) Smooth the center
        const targetXNorm = brightestX / offscreen.width;
        const targetYNorm = brightestY / offscreen.height;
        ufoCenterX = ufoCenterX * ufoSmoothing + targetXNorm * (1 - ufoSmoothing);
        ufoCenterY = ufoCenterY * ufoSmoothing + targetYNorm * (1 - ufoSmoothing);

        // 6) We want to zoom in around that pixel
        // Let's define how big the sub-rectangle is, in the source
        const zoomW = offscreen.width  / ufoDigitalZoom;
        const zoomH = offscreen.height / ufoDigitalZoom;

        // We want (ufoCenterX, ufoCenterY) in the center of that sub-rect
        const left = (ufoCenterX * offscreen.width) - (zoomW / 2);
        const top  = (ufoCenterY * offscreen.height) - (zoomH / 2);

        // 7) clamp the sub-rectangle
        let srcX = Math.max(0, Math.min(offscreen.width - zoomW, left));
        let srcY = Math.max(0, Math.min(offscreen.height - zoomH, top));

        // 8) Draw that subregion to the final canvas
        ctx.drawImage(
          offscreen,
          srcX, srcY,         // top-left in the offscreen
          zoomW, zoomH,       // subregion size
          0, 0,               // destination coords
          canvasElement.width,
          canvasElement.height
        );
      }

      //--- Voice Recognition ------------------------------------------------
      function startVoiceRecognition() {
        if ('webkitSpeechRecognition' in window) {
          recognition = new webkitSpeechRecognition();
        } else if ('SpeechRecognition' in window) {
          recognition = new SpeechRecognition();
        } else {
          alert('Speech recognition not supported in this browser.');
          return;
        }

        recognition.lang = 'en-US';
        recognition.continuous = true;
        recognition.interimResults = false;

        recognition.onresult = event => {
          for (let i = event.resultIndex; i < event.results.length; i++) {
            if (event.results[i].isFinal) {
              const cmd = event.results[i][0].transcript.trim().toLowerCase();
              processVoiceCommand(cmd);
            }
          }
        };
        recognition.onerror = e => console.error('Speech error:', e.error);
        recognition.onend = () => {
          if (!isMenuVisible) recognition.start();
        };

        recognition.start();
        isListening = true;
      }

      function stopVoiceRecognition() {
        if (recognition && isListening) {
          recognition.stop();
          isListening = false;
        }
      }

      function processVoiceCommand(command) {
        console.log('Heard:', command);

        // Possibly replace number words
        command = command.replace(/\bone\b/g, '1')
                         .replace(/\btwo\b/g, '2')
                         .replace(/\bthree\b/g, '3')
                         .replace(/\bfour\b/g, '4')
                         .replace(/\bfive\b/g, '5')
                         .replace(/\bsix\b/g, '6')
                         .replace(/\bseven\b/g, '7')
                         .replace(/\beight\b/g, '8')
                         .replace(/\bnine\b/g, '9')
                         .replace(/\bten\b/g, '10');

        // "enable filter 1" or "enable filter 2" or "disable filter"
        const filterMatch = command.match(/(enable|disable)\s*filter\s*(\d*)/);
        if (filterMatch) {
          const action = filterMatch[1];
          let filterNum = parseInt(filterMatch[2] || '0');
          if (action === 'disable') {
            filterMode = 0;
          } else {
            // "enable"
            if (filterNum === 1) {
              filterMode = 1; // motion
            } else if (filterNum === 2) {
              filterMode = 2; // UFO
              // reset UFO defaults so it starts fresh
              ufoDigitalZoom = 3.0;
              ufoCenterX = 0.5;
              ufoCenterY = 0.5;
            } else {
              // if no number, default to UFO
              filterMode = 2;
              ufoDigitalZoom = 3.0;
              ufoCenterX = 0.5;
              ufoCenterY = 0.5;
            }
          }
          updateFilterState();
          return;
        }

        // "push" / "pull" if UFO
        if (filterMode === 2) {
          if (command.includes('push')) {
            ufoDigitalZoom *= 1.25; // zoom in
            return;
          }
          if (command.includes('pull')) {
            ufoDigitalZoom /= 1.25; // zoom out
            if (ufoDigitalZoom < 1) ufoDigitalZoom = 1;
            return;
          }
        }

        // "frame rate 30"
        const frMatch = command.match(/frame\s*rate\s*(\d+)/);
        if (frMatch) {
          const val = parseInt(frMatch[1]);
          if (val >= 15 && val <= 60) {
            frameRateSlider.value = val;
            updateFrameRate();
          }
          return;
        }

        // "flip camera"
        if (command.includes('flip camera')) {
          flipCamera();
          return;
        }
        // "cycle camera"
        if (command.includes('cycle camera') || command.includes('cycle cam')) {
          cycleCamera();
          return;
        }
        // "switch to cam x"
        const switchMatch = command.match(/switch to cam\s*(\d+)/);
        if (switchMatch) {
          const num = parseInt(switchMatch[1]);
          if (!isNaN(num)) switchToCameraByName(`Cam ${num}`);
          return;
        }

        // "enable hdr" / "disable hdr"
        if (command.includes('enable hdr')) {
          if (!hdrEnabled) toggleHDR();
          return;
        }
        if (command.includes('disable hdr')) {
          if (hdrEnabled) toggleHDR();
          return;
        }

        // "brightness 10"
        const brightMatch = command.match(/brightness\s*(\d+)/);
        if (brightMatch) {
          const bval = parseInt(brightMatch[1]);
          if (bval >= 0 && bval <= 20) {
            brightnessSlider.value = bval;
            applyBrightnessContrast();
          }
          return;
        }
        // "contrast 15"
        const contrastMatch = command.match(/contrast\s*(\d+)/);
        if (contrastMatch) {
          const cval = parseInt(contrastMatch[1]);
          if (cval >= 0 && cval <= 20) {
            contrastSlider.value = cval;
            applyBrightnessContrast();
          }
          return;
        }

        // motion filter intensity
        const intensityMatch = command.match(/intensity\s*(\d+)/);
        if (intensityMatch) {
          const ival = parseInt(intensityMatch[1]);
          if (ival >= 0 && ival <= 100) {
            amplificationFactor = ival;
          }
          return;
        }
        // motion filter sensitivity
        const sensMatch = command.match(/sensitivity\s*(\d+)/);
        if (sensMatch) {
          const sval = parseInt(sensMatch[1]);
          if (sval >= 0 && sval <= 100) {
            sensitivity = sval / 100;
          }
          return;
        }
      }

      //--- UI Update ---------------------------------------------------------
      function updateFilterState() {
        if (filterMode === 0) {
          // no filter
          video1.style.visibility = 'visible';
          video2.style.visibility = 'visible';
          canvas1.style.display = 'none';
          canvas2.style.display = 'none';
          video1.previousFrameData = null;
          video2.previousFrameData = null;
        } else {
          // hide original, show canvas
          video1.style.visibility = 'hidden';
          video2.style.visibility = 'hidden';
          canvas1.style.display = 'block';
          canvas2.style.display = 'block';
          // reset prev data
          video1.previousFrameData = null;
          video2.previousFrameData = null;
        }
      }

      //--- General Camera & UI -----------------------------------------------
      function flipCamera() {
        isFrontCamera = !isFrontCamera;
        currentZoom = 1;
        lastZoom = 1;
        restartCamera();
      }

      async function cycleCamera() {
        if (videoDevices.length > 1) {
          currentCameraToggleIndex = (currentCameraToggleIndex + 1) % videoDevices.length;
          await restartCamera();
          updateCameraLabel();
        }
      }

      function updateCameraLabel() {
        const label = cameraLabels[currentCameraToggleIndex] || `Cam ${currentCameraToggleIndex + 1}`;
        cameraLabelOverlay.textContent = label;
        cameraLabelOverlay.style.display = 'block';
        setTimeout(() => {
          cameraLabelOverlay.style.display = 'none';
        }, 3000);
      }

      async function switchToCameraByName(camName) {
        const camNumber = parseInt(camName.replace('Cam ', ''));
        const idx = camNumber - 1;
        if (idx >= 0 && idx < videoDevices.length) {
          currentCameraToggleIndex = idx;
          await restartCamera();
          updateCameraLabel();
        }
      }

      async function toggleHDR() {
        hdrEnabled = !hdrEnabled;
        hdrToggleBtn.textContent = hdrEnabled ? 'Disable HDR' : 'Enable HDR';
        await restartCamera();
      }

      function updateFrameRate() {
        frameRateValue.textContent = `${frameRateSlider.value} fps`;
        restartCamera();
      }

      function applyBrightnessContrast() {
        const b = parseInt(brightnessSlider.value);
        const c = parseInt(contrastSlider.value);
        video1.style.filter = `brightness(${b * 5}%) contrast(${c * 5}%)`;
        video2.style.filter = `brightness(${b * 5}%) contrast(${c * 5}%)`;
        brightnessValue.textContent = b;
        contrastValue.textContent = c;
      }

      // Positioning
      function updateVideoPositions() {
        video1.style.transform = `translate(${leftX.value}px, ${leftY.value}px)`;
        video2.style.transform = `translate(${rightX.value}px, ${rightY.value}px)`;
        canvas1.style.transform = `translate(${leftX.value}px, ${leftY.value}px)`;
        canvas2.style.transform = `translate(${rightX.value}px, ${rightY.value}px)`;
      }

      //--- Touch Zoom Logic --------------------------------------------------
      function handleTouchStart(e) {
        if (e.touches.length === 2) {
          initialPinchDistance = getPinchDistance(e.touches);
        } else if (e.touches.length === 1) {
          const now = Date.now();
          if (handleTouchStart.last && (now - handleTouchStart.last) < 300) {
            // double tap
            toggleMenu();
          }
          handleTouchStart.last = now;
        }
      }

      function handleTouchMove(e) {
        if (e.touches.length === 2 && capabilities && capabilities.zoom) {
          const pinchDistance = getPinchDistance(e.touches);
          if (initialPinchDistance) {
            const factor = pinchDistance / initialPinchDistance;
            let newZoom = lastZoom * factor;

            newZoom = Math.max(capabilities.zoom.min, Math.min(newZoom, capabilities.zoom.max));
            track.applyConstraints({ advanced: [{ zoom: newZoom }] });
            currentZoom = newZoom;
          }
        }
      }

      function handleTouchEnd(e) {
        if (e.touches.length < 2) {
          lastZoom = currentZoom;
          initialPinchDistance = null;
        }
      }

      function getPinchDistance(touches) {
        const dx = touches[0].clientX - touches[1].clientX;
        const dy = touches[0].clientY - touches[1].clientY;
        return Math.hypot(dx, dy);
      }

      //--- Show/Hide Menu ----------------------------------------------------
      function toggleMenu() {
        isMenuVisible = !isMenuVisible;
        menu.style.display = isMenuVisible ? 'block' : 'none';

        if (isMenuVisible) {
          stopVoiceRecognition();
        } else {
          startVoiceRecognition();
        }
      }

      //--- Full-Screen Toggle ------------------------------------------------
      const fullscreenOverlay = document.getElementById('fullscreenOverlay');
      fullscreenOverlay.addEventListener('click', function() {
        if (document.fullscreenElement) {
          document.exitFullscreen();
        } else {
          if (document.body.requestFullscreen) {
            document.body.requestFullscreen();
          } else if (document.body.webkitRequestFullscreen) {
            document.body.webkitRequestFullscreen();
          }
        }
      });

      //--- Orientation Layout ------------------------------------------------
      window.addEventListener('resize', adjustLayout);
      function adjustLayout() {
        const container = document.getElementById('videoContainer');
        if (window.innerWidth > window.innerHeight) {
          container.style.flexDirection = 'row';
        } else {
          container.style.flexDirection = 'column';
        }
      }
      adjustLayout();

    })();
  </script>
</body>
</html>
