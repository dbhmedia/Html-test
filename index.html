<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Camera App (Motion + UFO Filter + Take Picture)</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: black;
      width: 100%;
      height: 100%;
      touch-action: none;
    }
    #videoContainer {
      position: relative;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: row; /* We'll adjust to column in JS if portrait */
      justify-content: center;
      align-items: center;
    }

    /* The two video elements and two canvases (left, right) */
    video, canvas {
      position: absolute;
      width: 50%;
      height: 100%;
      object-fit: cover;
    }
    #video1, #canvas1 {
      left: 0;  /* Left half of screen */
    }
    #video2, #canvas2 {
      right: 0; /* Right half of screen */
    }

    /* The on-screen menu (sliders, etc.) */
    #menu {
      position: absolute;
      top: 10%;
      left: 50%;
      transform: translateX(-50%);
      background-color: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border-radius: 10px;
      display: none; /* Hidden by default; toggled by double-tap */
      color: white;
      z-index: 2;
    }
    #menu h2 {
      margin-top: 0;
    }
    .sliderContainer {
      margin: 10px 0;
    }
    .sliderLabel {
      margin-bottom: 5px;
    }
    .slider {
      width: 100%;
    }
    .valueDisplay {
      color: #fff;
      font-size: 14px;
      margin-left: 10px;
    }
    .button {
      background-color: #444;
      color: white;
      padding: 10px;
      margin: 10px 0;
      border: none;
      border-radius: 5px;
      width: 100%;
      font-size: 16px;
    }

    /* Full-screen toggle overlay */
    #fullscreenOverlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }

    /* Camera label overlay (e.g. "Cam 1") */
    #cameraLabel {
      position: absolute;
      top: 10px;
      right: 10px;
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 5px 10px;
      border-radius: 5px;
      z-index: 3;
      font-size: 16px;
      display: none;
    }
  </style>
</head>

<body>
  <div id="videoContainer">
    <!-- Left Camera / Canvas -->
    <video id="video1" autoplay playsinline></video>
    <canvas id="canvas1"></canvas>

    <!-- Right Camera / Canvas -->
    <video id="video2" autoplay playsinline></video>
    <canvas id="canvas2"></canvas>
  </div>

  <!-- Full-screen overlay (for toggling by a tap) -->
  <div id="fullscreenOverlay"></div>

  <!-- Camera label overlay -->
  <div id="cameraLabel">Cam 1</div>

  <!-- Menu for adjustments -->
  <div id="menu">
    <h2>Adjustments</h2>
    <!-- Flip Camera Button -->
    <button id="flipCameraBtn" class="button">Flip Camera</button>
    <!-- HDR Toggle -->
    <button id="hdrToggleBtn" class="button">Enable HDR</button>

    <!-- Frame Rate -->
    <div class="sliderContainer">
      <div class="sliderLabel">Frame Rate</div>
      <input type="range" id="frameRate" class="slider" min="15" max="60" value="30">
      <span id="frameRateValue" class="valueDisplay">30 fps</span>
    </div>

    <!-- Resolution -->
    <div class="sliderContainer">
      <div class="sliderLabel">Resolution</div>
      <select id="resolution" class="slider">
        <option value="1280x720">720p</option>
        <option value="1920x1080">1080p</option>
      </select>
    </div>

    <!-- Brightness -->
    <div class="sliderContainer">
      <div class="sliderLabel">Brightness</div>
      <input type="range" id="brightness" class="slider" min="0" max="20" value="10">
      <span id="brightnessValue" class="valueDisplay">10</span>
    </div>

    <!-- Contrast -->
    <div class="sliderContainer">
      <div class="sliderLabel">Contrast</div>
      <input type="range" id="contrast" class="slider" min="0" max="20" value="20">
      <span id="contrastValue" class="valueDisplay">20</span>
    </div>

    <!-- Processing Scale (only used for Motion filter) -->
    <div class="sliderContainer">
      <div class="sliderLabel">Motion Filter Scale Factor</div>
      <input type="range" id="scaleFactor" class="slider" min="10" max="100" value="25">
      <span id="scaleFactorValue" class="valueDisplay">25%</span>
    </div>

    <!-- Left Video Offsets -->
    <div class="sliderContainer">
      <div class="sliderLabel">Left Video X Position</div>
      <input type="range" id="leftX" class="slider" min="-50" max="50" value="28">
      <span id="leftXValue" class="valueDisplay">28</span>
    </div>
    <div class="sliderContainer">
      <div class="sliderLabel">Left Video Y Position</div>
      <input type="range" id="leftY" class="slider" min="-50" max="50" value="0">
      <span id="leftYValue" class="valueDisplay">0</span>
    </div>

    <!-- Right Video Offsets -->
    <div class="sliderContainer">
      <div class="sliderLabel">Right Video X Position</div>
      <input type="range" id="rightX" class="slider" min="-50" max="50" value="-29">
      <span id="rightXValue" class="valueDisplay">-29</span>
    </div>
    <div class="sliderContainer">
      <div class="sliderLabel">Right Video Y Position</div>
      <input type="range" id="rightY" class="slider" min="-50" max="50" value="0">
      <span id="rightYValue" class="valueDisplay">0</span>
    </div>
  </div>

  <script>
    (function() {
      // DOM elements
      const video1 = document.getElementById('video1');
      const video2 = document.getElementById('video2');
      const canvas1 = document.getElementById('canvas1');
      const canvas2 = document.getElementById('canvas2');

      const ctx1 = canvas1.getContext('2d');
      const ctx2 = canvas2.getContext('2d');

      const menu = document.getElementById('menu');
      const flipCameraBtn = document.getElementById('flipCameraBtn');
      const hdrToggleBtn = document.getElementById('hdrToggleBtn');

      const frameRateSlider = document.getElementById('frameRate');
      const frameRateValue = document.getElementById('frameRateValue');
      const resolutionSelect = document.getElementById('resolution');

      const brightnessSlider = document.getElementById('brightness');
      const brightnessValue = document.getElementById('brightnessValue');
      const contrastSlider = document.getElementById('contrast');
      const contrastValue = document.getElementById('contrastValue');

      const scaleFactorSlider = document.getElementById('scaleFactor');
      const scaleFactorValue = document.getElementById('scaleFactorValue');

      const leftX = document.getElementById('leftX');
      const leftY = document.getElementById('leftY');
      const rightX = document.getElementById('rightX');
      const rightY = document.getElementById('rightY');

      const leftXValue = document.getElementById('leftXValue');
      const leftYValue = document.getElementById('leftYValue');
      const rightXValue = document.getElementById('rightXValue');
      const rightYValue = document.getElementById('rightYValue');

      const cameraLabelOverlay = document.getElementById('cameraLabel');

      // Touch / UI
      let isMenuVisible = false;
      let initialPinchDistance = null;
      let lastZoom = 1;

      // Camera handling
      let stream = null;
      let track = null;
      let capabilities = null;
      let settings = null;
      let currentZoom = 1;
      let isFrontCamera = false;
      let hdrEnabled = false;

      let videoDevices = [];
      let currentCameraToggleIndex = 0;
      let cameraLabels = [];

      // Voice
      let recognition = null;
      let isListening = false;

      // filterMode: 0=none, 1=motion, 2=UFO
      let filterMode = 0;

      // Motion filter variables
      let amplificationFactor = 100;  // "intensity"
      let sensitivity = 1.0;         // "sensitivity"
      let smoothingFactor = 0.5;     // smoothing
      let scaleFactor = 0.25;        // for motion filter

      // UFO filter variables
      let ufoCenterX = 0.5;
      let ufoCenterY = 0.5;
      let ufoDigitalZoom = 3.0;   // default 3x
      let ufoSmoothing = 0.9;

      //--- Initialization ----------------------------------------------------
      async function init() {
        await getVideoDevices();

        if (videoDevices.length === 0) {
          alert('No video devices found.');
          return;
        }

        // Start with the first camera
        currentCameraToggleIndex = 0;
        await restartCamera();

        // Add event listeners
        document.addEventListener('touchstart', handleTouchStart, false);
        document.addEventListener('touchmove', handleTouchMove, false);
        document.addEventListener('touchend', handleTouchEnd, false);

        frameRateSlider.addEventListener('input', updateFrameRate);
        resolutionSelect.addEventListener('change', restartCamera);
        brightnessSlider.addEventListener('input', applyBrightnessContrast);
        contrastSlider.addEventListener('input', applyBrightnessContrast);
        scaleFactorSlider.addEventListener('input', updateScaleFactor);

        [leftX, leftY, rightX, rightY].forEach(slider => {
          slider.addEventListener('input', updateVideoPositions);
        });

        flipCameraBtn.addEventListener('click', flipCamera);
        hdrToggleBtn.addEventListener('click', toggleHDR);

        // Initial UI
        updateFrameRate();
        applyBrightnessContrast();
        updateScaleFactor();
        updateVideoPositions();

        startVoiceRecognition();
        processFrames();
        updateFilterState();
        adjustLayout();
      }
      init();

      //--- Enumerate Devices -------------------------------------------------
      async function getVideoDevices() {
        const devices = await navigator.mediaDevices.enumerateDevices();
        videoDevices = devices.filter(d => d.kind === 'videoinput');
        cameraLabels = videoDevices.map((device, i) => `Cam ${i + 1}`);
      }

      //--- Start / Restart Camera --------------------------------------------
      async function restartCamera() {
        const deviceId = videoDevices[currentCameraToggleIndex]?.deviceId;
        await startCamera(deviceId, isFrontCamera ? 'user' : 'environment');
      }

      async function startCamera(deviceId, facingMode) {
        if (stream) {
          stream.getTracks().forEach(t => t.stop());
        }

        const frameRate = parseInt(frameRateSlider.value);
        const [width, height] = resolutionSelect.value.split('x').map(Number);

        let constraints = {
          audio: false,
          video: {
            width: { ideal: width },
            height: { ideal: height },
            frameRate: { ideal: frameRate },
          },
        };

        if (deviceId) {
          constraints.video.deviceId = { exact: deviceId };
        } else if (facingMode) {
          constraints.video.facingMode = { exact: facingMode };
        } else {
          constraints.video.facingMode = { ideal: 'environment' };
        }

        try {
          stream = await navigator.mediaDevices.getUserMedia(constraints);
          video1.srcObject = stream;
          video2.srcObject = stream;

          track = stream.getVideoTracks()[0];
          capabilities = track.getCapabilities ? track.getCapabilities() : {};
          settings = track.getSettings ? track.getSettings() : {};

          updateCameraLabel();

          if (capabilities.zoom) {
            currentZoom = capabilities.zoom.min || 1;
            lastZoom = currentZoom;
          }

          video1.onloadedmetadata = () => {
            canvas1.width = video1.videoWidth;
            canvas1.height = video1.videoHeight;
          };
          video2.onloadedmetadata = () => {
            canvas2.width = video2.videoWidth;
            canvas2.height = video2.videoHeight;
          };
        } catch (err) {
          console.error('Camera start error:', err);
          alert(`Error starting camera: ${err.message}`);
        }
      }

      //--- FILTER LOOP -------------------------------------------------------
      function processFrames() {
        if (filterMode === 1) {
          // Motion filter
          processMotionFrame(video1, canvas1, ctx1);
          processMotionFrame(video2, canvas2, ctx2);
        } else if (filterMode === 2) {
          // UFO filter
          processUfoFrame(video1, canvas1, ctx1);
          processUfoFrame(video2, canvas2, ctx2);
        }
        requestAnimationFrame(processFrames);
      }

      /*************************************************
       * MOTION FILTER
       *************************************************/
      function processMotionFrame(videoElement, canvasElement, ctx) {
        if (!videoElement || videoElement.readyState < 2) return;

        // We'll create an offscreen with "scaled" resolution
        // to do motion detection at a lower resolution = faster
        const scaledWidth = Math.floor(videoElement.videoWidth * scaleFactor);
        const scaledHeight = Math.floor(videoElement.videoHeight * scaleFactor);

        const offscreen = document.createElement('canvas');
        offscreen.width = scaledWidth;
        offscreen.height = scaledHeight;
        const offCtx = offscreen.getContext('2d');

        // draw raw camera feed at scaled size
        offCtx.drawImage(videoElement, 0, 0, scaledWidth, scaledHeight);
        const currentFrame = offCtx.getImageData(0, 0, scaledWidth, scaledHeight);

        let prevData = videoElement.previousFrameData;
        if (prevData) {
          const data = currentFrame.data;
          const len = data.length;
          const outData = new Uint8ClampedArray(len);

          const threshold = 255 * (1 - sensitivity);

          for (let i = 0; i < len; i += 4) {
            const diffR = data[i] - prevData[i];
            const diffG = data[i + 1] - prevData[i + 1];
            const diffB = data[i + 2] - prevData[i + 2];

            const motionVal = Math.sqrt(diffR * diffR + diffG * diffG + diffB * diffB);

            // smoothing into prev
            prevData[i]   = prevData[i]   * smoothingFactor + data[i]   * (1 - smoothingFactor);
            prevData[i+1] = prevData[i+1] * smoothingFactor + data[i+1] * (1 - smoothingFactor);
            prevData[i+2] = prevData[i+2] * smoothingFactor + data[i+2] * (1 - smoothingFactor);

            if (motionVal > threshold) {
              outData[i]   = clamp(data[i]   + diffR * amplificationFactor);
              outData[i+1] = clamp(data[i+1] + diffG * amplificationFactor);
              outData[i+2] = clamp(data[i+2] + diffB * amplificationFactor);
            } else {
              outData[i]   = data[i];
              outData[i+1] = data[i + 1];
              outData[i+2] = data[i + 2];
            }
            outData[i+3] = 255;
          }

          const outFrame = new ImageData(outData, scaledWidth, scaledHeight);
          offCtx.putImageData(outFrame, 0, 0);
        }
        videoElement.previousFrameData = currentFrame.data.slice();

        // scale back up to canvas size
        ctx.drawImage(offscreen, 0, 0, scaledWidth, scaledHeight,
                                 0, 0, canvasElement.width, canvasElement.height);
      }

      function clamp(v) {
        return Math.max(0, Math.min(255, v));
      }

      /*************************************************
       * UFO FILTER (single brightest pixel)
       *************************************************/
      function processUfoFrame(videoElement, canvasElement, ctx) {
        if (!videoElement || videoElement.readyState < 2) return;

        // Full-resolution offscreen
        const offscreen = document.createElement('canvas');
        offscreen.width = videoElement.videoWidth;
        offscreen.height = videoElement.videoHeight;
        const offCtx = offscreen.getContext('2d');

        offCtx.drawImage(videoElement, 0, 0);
        const frameData = offCtx.getImageData(0, 0, offscreen.width, offscreen.height);

        let brightestVal = -1;
        let brightestX = 0;
        let brightestY = 0;

        const len = frameData.data.length;
        for (let i = 0; i < len; i += 4) {
          const r = frameData.data[i];
          const g = frameData.data[i + 1];
          const b = frameData.data[i + 2];
          const bright = (r + g + b) / 3;
          if (bright > brightestVal) {
            brightestVal = bright;
            let pxIndex = i / 4;
            brightestX = pxIndex % offscreen.width;
            brightestY = Math.floor(pxIndex / offscreen.width);
          }
        }

        if (brightestVal < 0) {
          // no bright pixel
          ctx.drawImage(offscreen, 0, 0, canvasElement.width, canvasElement.height);
          return;
        }

        // smooth center
        const targetXNorm = brightestX / offscreen.width;
        const targetYNorm = brightestY / offscreen.height;
        ufoCenterX = ufoCenterX * ufoSmoothing + targetXNorm * (1 - ufoSmoothing);
        ufoCenterY = ufoCenterY * ufoSmoothing + targetYNorm * (1 - ufoSmoothing);

        const zoomW = offscreen.width  / ufoDigitalZoom;
        const zoomH = offscreen.height / ufoDigitalZoom;

        const left = (ufoCenterX * offscreen.width) - (zoomW / 2);
        const top  = (ufoCenterY * offscreen.height) - (zoomH / 2);

        let srcX = Math.max(0, Math.min(offscreen.width - zoomW, left));
        let srcY = Math.max(0, Math.min(offscreen.height - zoomH, top));

        ctx.drawImage(offscreen,
          srcX, srcY, zoomW, zoomH,
          0, 0, canvasElement.width, canvasElement.height
        );
      }

      //--- VOICE -------------------------------------------------------------
      function startVoiceRecognition() {
        if ('webkitSpeechRecognition' in window) {
          recognition = new webkitSpeechRecognition();
        } else if ('SpeechRecognition' in window) {
          recognition = new SpeechRecognition();
        } else {
          alert('Speech recognition not supported in this browser.');
          return;
        }

        recognition.lang = 'en-US';
        recognition.continuous = true;
        recognition.interimResults = false;

        recognition.onresult = function(e) {
          for (let i = e.resultIndex; i < e.results.length; i++) {
            if (e.results[i].isFinal) {
              const command = e.results[i][0].transcript.trim().toLowerCase();
              processVoiceCommand(command);
            }
          }
        };
        recognition.onerror = function(evt) {
          console.error('Voice error:', evt.error);
        };
        recognition.onend = function() {
          if (!isMenuVisible) recognition.start();
        };

        recognition.start();
        isListening = true;
      }

      function stopVoiceRecognition() {
        if (recognition && isListening) {
          recognition.stop();
          isListening = false;
        }
      }

      function processVoiceCommand(command) {
        console.log('Voice cmd:', command);

        // optional number word replacements
        command = command
          .replace(/\bone\b/g, '1')
          .replace(/\btwo\b/g, '2')
          .replace(/\bthree\b/g, '3')
          .replace(/\bfour\b/g, '4')
          .replace(/\bfive\b/g, '5')
          .replace(/\bsix\b/g, '6')
          .replace(/\bseven\b/g, '7')
          .replace(/\beight\b/g, '8')
          .replace(/\bnine\b/g, '9')
          .replace(/\bten\b/g, '10');

        // Filter commands: "enable filter 1" or "enable filter 2" or "disable filter"
        const filterMatch = command.match(/(enable|disable)\s*filter\s*(\d*)/);
        if (filterMatch) {
          const action = filterMatch[1];
          let filterNum = parseInt(filterMatch[2] || '0');
          if (action === 'disable') {
            filterMode = 0;
          } else {
            // enable
            if (filterNum === 1) {
              filterMode = 1; // motion
            } else if (filterNum === 2) {
              filterMode = 2; // UFO
              ufoDigitalZoom = 3.0; // reset UFO defaults
              ufoCenterX = 0.5;
              ufoCenterY = 0.5;
            } else {
              // if no number, default to UFO
              filterMode = 2;
              ufoDigitalZoom = 3.0;
              ufoCenterX = 0.5;
              ufoCenterY = 0.5;
            }
          }
          updateFilterState();
          return;
        }

        // "take picture"
        if (command.includes('take picture')) {
          takePicture();
          return;
        }

        // If UFO filter is on, "push"/"pull" for zoom
        if (filterMode === 2) {
          if (command.includes('push')) {
            // zoom in
            ufoDigitalZoom *= 1.25;
            return;
          }
          if (command.includes('pull')) {
            // zoom out
            ufoDigitalZoom /= 1.25;
            if (ufoDigitalZoom < 1) ufoDigitalZoom = 1;
            return;
          }
        }

        // motion filter intensity/sensitivity
        const intensityMatch = command.match(/intensity\s*(\d+)/);
        if (intensityMatch) {
          const ival = parseInt(intensityMatch[1]);
          if (ival >= 0 && ival <= 100) {
            amplificationFactor = ival;
          }
          return;
        }
        const sensMatch = command.match(/sensitivity\s*(\d+)/);
        if (sensMatch) {
          const sval = parseInt(sensMatch[1]);
          if (sval >= 0 && sval <= 100) {
            sensitivity = sval / 100;
          }
          return;
        }

        // "frame rate 30"
        const frMatch = command.match(/frame\s*rate\s*(\d+)/);
        if (frMatch) {
          const val = parseInt(frMatch[1]);
          if (val >= 15 && val <= 60) {
            frameRateSlider.value = val;
            updateFrameRate();
          }
          return;
        }

        // "flip camera"
        if (command.includes('flip camera')) {
          flipCamera();
          return;
        }

        // "cycle camera"
        if (command.includes('cycle camera') || command.includes('cycle cam')) {
          cycleCamera();
          return;
        }

        // "switch to cam x"
        const switchMatch = command.match(/switch to cam\s*(\d+)/);
        if (switchMatch) {
          const cnum = parseInt(switchMatch[1]);
          switchToCameraByName(`Cam ${cnum}`);
          return;
        }

        // "enable hdr" / "disable hdr"
        if (command.includes('enable hdr')) {
          if (!hdrEnabled) toggleHDR();
          return;
        }
        if (command.includes('disable hdr')) {
          if (hdrEnabled) toggleHDR();
          return;
        }

        // "brightness 10"
        const brightMatch = command.match(/brightness\s*(\d+)/);
        if (brightMatch) {
          const bval = parseInt(brightMatch[1]);
          if (bval >= 0 && bval <= 20) {
            brightnessSlider.value = bval;
            applyBrightnessContrast();
          }
          return;
        }

        // "contrast 15"
        const contrastMatch = command.match(/contrast\s*(\d+)/);
        if (contrastMatch) {
          const cval = parseInt(contrastMatch[1]);
          if (cval >= 0 && cval <= 20) {
            contrastSlider.value = cval;
            applyBrightnessContrast();
          }
          return;
        }
      }

      //--- TAKE PICTURE ------------------------------------------------------
      function takePicture() {
        // We'll combine canvas1 and canvas2 side by side into a single snapshot
        // that matches the final user view (left half, right half).

        // Both canvases are presumably the same height, so let's do:
        const w = canvas1.width + canvas2.width;
        const h = Math.max(canvas1.height, canvas2.height);

        // Create an offscreen to combine them
        const combined = document.createElement('canvas');
        combined.width = w;
        combined.height = h;
        const cctx = combined.getContext('2d');

        // Draw left canvas at [0,0]
        cctx.drawImage(canvas1, 0, 0, canvas1.width, canvas1.height);

        // Draw right canvas at [canvas1.width, 0]
        cctx.drawImage(canvas2, canvas1.width, 0, canvas2.width, canvas2.height);

        // Generate a random file name
        const randomName = 'snapshot_' + Math.random().toString(36).slice(2, 10) + '.png';

        // Convert to dataURL
        const url = combined.toDataURL('image/png');

        // Create an <a> link to force a download
        const a = document.createElement('a');
        a.href = url;
        a.download = randomName;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
      }

      //--- UI / Filter States -----------------------------------------------
      function updateFilterState() {
        if (filterMode === 0) {
          // no filter
          video1.style.visibility = 'visible';
          video2.style.visibility = 'visible';
          canvas1.style.display = 'none';
          canvas2.style.display = 'none';
          video1.previousFrameData = null;
          video2.previousFrameData = null;
        } else {
          video1.style.visibility = 'hidden';
          video2.style.visibility = 'hidden';
          canvas1.style.display = 'block';
          canvas2.style.display = 'block';
          video1.previousFrameData = null;
          video2.previousFrameData = null;
        }
      }

      //--- Camera / Layout ---------------------------------------------------
      function flipCamera() {
        isFrontCamera = !isFrontCamera;
        currentZoom = 1;
        lastZoom = 1;
        restartCamera();
      }

      async function cycleCamera() {
        if (videoDevices.length > 1) {
          currentCameraToggleIndex = (currentCameraToggleIndex + 1) % videoDevices.length;
          await restartCamera();
          updateCameraLabel();
        }
      }

      function updateCameraLabel() {
        const label = cameraLabels[currentCameraToggleIndex] || `Cam ${currentCameraToggleIndex + 1}`;
        cameraLabelOverlay.textContent = label;
        cameraLabelOverlay.style.display = 'block';
        setTimeout(() => {
          cameraLabelOverlay.style.display = 'none';
        }, 3000);
      }

      async function switchToCameraByName(camName) {
        const n = parseInt(camName.replace('Cam ', ''));
        const idx = n - 1;
        if (idx >= 0 && idx < videoDevices.length) {
          currentCameraToggleIndex = idx;
          await restartCamera();
          updateCameraLabel();
        }
      }

      async function toggleHDR() {
        hdrEnabled = !hdrEnabled;
        hdrToggleBtn.textContent = hdrEnabled ? 'Disable HDR' : 'Enable HDR';
        await restartCamera();
      }

      //--- Sliders -----------------------------------------------------------
      function updateFrameRate() {
        frameRateValue.textContent = `${frameRateSlider.value} fps`;
        restartCamera();
      }

      function applyBrightnessContrast() {
        const b = parseInt(brightnessSlider.value);
        const c = parseInt(contrastSlider.value);
        video1.style.filter = `brightness(${b * 5}%) contrast(${c * 5}%)`;
        video2.style.filter = `brightness(${b * 5}%) contrast(${c * 5}%)`;
        brightnessValue.textContent = b;
        contrastValue.textContent = c;
      }

      function updateScaleFactor() {
        const val = parseInt(scaleFactorSlider.value);
        scaleFactor = val / 100;
        scaleFactorValue.textContent = `${val}%`;

        video1.previousFrameData = null;
        video2.previousFrameData = null;
      }

      function updateVideoPositions() {
        video1.style.transform = `translate(${leftX.value}px, ${leftY.value}px)`;
        canvas1.style.transform = `translate(${leftX.value}px, ${leftY.value}px)`;

        video2.style.transform = `translate(${rightX.value}px, ${rightY.value}px)`;
        canvas2.style.transform = `translate(${rightX.value}px, ${rightY.value}px)`;

        leftXValue.textContent = leftX.value;
        leftYValue.textContent = leftY.value;
        rightXValue.textContent = rightX.value;
        rightYValue.textContent = rightY.value;
      }

      //--- Touch (zoom) / Menu toggles ---------------------------------------
      function handleTouchStart(e) {
        if (e.touches.length === 2) {
          initialPinchDistance = getPinchDistance(e.touches);
        } else if (e.touches.length === 1) {
          // single tap => check for double-tap
          const now = Date.now();
          if (handleTouchStart.last && (now - handleTouchStart.last) < 300) {
            // double tap => toggle menu
            toggleMenu();
          }
          handleTouchStart.last = now;
        }
      }

      function handleTouchMove(e) {
        if (e.touches.length === 2 && capabilities && capabilities.zoom) {
          const pinchDistance = getPinchDistance(e.touches);
          if (initialPinchDistance) {
            const factor = pinchDistance / initialPinchDistance;
            let newZoom = lastZoom * factor;

            newZoom = Math.max(capabilities.zoom.min, Math.min(newZoom, capabilities.zoom.max));
            track.applyConstraints({ advanced: [{ zoom: newZoom }] });
            currentZoom = newZoom;
          }
        }
      }

      function handleTouchEnd(e) {
        if (e.touches.length < 2) {
          lastZoom = currentZoom;
          initialPinchDistance = null;
        }
      }

      function getPinchDistance(touches) {
        const dx = touches[0].clientX - touches[1].clientX;
        const dy = touches[0].clientY - touches[1].clientY;
        return Math.hypot(dx, dy);
      }

      function toggleMenu() {
        isMenuVisible = !isMenuVisible;
        menu.style.display = isMenuVisible ? 'block' : 'none';

        if (isMenuVisible) stopVoiceRecognition();
        else startVoiceRecognition();
      }

      //--- Orientation & Fullscreen ------------------------------------------
      window.addEventListener('resize', adjustLayout);
      function adjustLayout() {
        const container = document.getElementById('videoContainer');
        if (window.innerWidth > window.innerHeight) {
          container.style.flexDirection = 'row';
        } else {
          container.style.flexDirection = 'column';
        }
      }

      const fullscreenOverlay = document.getElementById('fullscreenOverlay');
      fullscreenOverlay.addEventListener('click', function() {
        if (document.fullscreenElement) {
          document.exitFullscreen();
        } else {
          if (document.body.requestFullscreen) {
            document.body.requestFullscreen();
          } else if (document.body.webkitRequestFullscreen) {
            document.body.webkitRequestFullscreen();
          }
        }
      });

    })();
  </script>
</body>
</html>
